<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>REAL TIME WIN - VIP</title>

    <!-- TensorFlow JS (kept in case you add AI later) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- FontAwesome Icons & Tailwind CSS -->
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            color: #ffffff;
            overflow-y: auto;
        }

        .container {
            max-width: 480px;
            margin: 20px auto;
            padding: 24px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            animation: fadeIn 0.8s ease-in-out;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
                transform: translateY(-20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .heading {
            font-size: 24px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 24px;
            text-align: center;
            animation: glow 2.5s infinite;
        }

        @keyframes glow {
            0%,
            100% {
                text-shadow: 0 0 8px #00ff00, 0 0 14px #00ff00;
            }

            50% {
                text-shadow: 0 0 14px #ff00ff, 0 0 22px #ff00ff;
            }
        }

        .box {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 16px;
            transition: transform 0.28s ease, box-shadow 0.28s ease;
        }

        .box:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ff00ff);
            border-radius: 6px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .history-table-header {
            background-color: #2f855a; /* green header */
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* small responsive tweaks */
        @media (max-width: 520px) {
            .container {
                margin: 12px;
                padding: 16px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="heading">
            REAL TIME WIN <span class="text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-purple-400">VIP</span>
        </h1>

        <!-- Period & Prediction -->
        <div class="box text-center">
            <p class="text-lg font-semibold text-gray-300">
                <i class="fas fa-calendar-alt"></i> Period:
                <span id="period-number" class="text-white">Loading...</span>
            </p>
            <p class="text-lg font-semibold text-gray-300 mt-2">
                <i class="fas fa-chart-line"></i> Prediction:
                <span id="predicted-result"
                    class="text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-purple-400 font-bold">Loading...</span>
            </p>

            <div class="progress-bar mt-3">
                <div id="progress-bar-fill" class="progress-bar-fill"></div>
            </div>
        </div>

        <!-- Analysis -->
        <div class="box mt-6">
            <h2 class="text-lg font-semibold text-gray-300 text-center">Analysis</h2>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <div class="bg-gray-800 p-4 rounded-lg text-center history-box">
                    <p class="text-gray-300">Prediction Win</p>
                    <p id="won-count" class="text-xl font-bold text-green-400">0</p>
                </div>
                <div class="bg-gray-800 p-4 rounded-lg text-center history-box">
                    <p class="text-gray-300">Prediction Loss</p>
                    <p id="lost-count" class="text-xl font-bold text-red-400">0</p>
                </div>
            </div>
        </div>

        <!-- History Table (last 10) -->
        <div class="box mt-6">
            <h2 class="text-lg font-semibold text-gray-300 text-center mb-4">Winning History (Last 10)</h2>
            <div class="overflow-x-auto" id="history-table-container" style="max-height:400px; overflow-y:auto;">
                <table class="w-full text-sm text-left text-gray-400 table-fixed">
                    <thead class="text-xs uppercase text-white history-table-header">
                        <tr>
                            <th scope="col" class="py-2 px-1 w-1/4">Period</th>
                            <th scope="col" class="py-2 px-1 w-1/4 text-center">Number</th>
                            <th scope="col" class="py-2 px-1 w-1/4 text-center">Big Small</th>
                            <th scope="col" class="py-2 px-1 w-1/4 text-center">Color</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                        <!-- Rows inserted by JS -->
                    </tbody>
                </table>
            </div>
        </div>

        <h4 class="heading text-base mt-4">
            REAL TIME WIN <span class="text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-purple-400">VIP</span>
            <a href="https://t.me/RK_TRADER_TOP_VIP" target="_blank" class="text-blue-400 hover:text-blue-300 ml-2">
                <i class="fab fa-telegram"></i> Join Telegram
            </a>
        </h4>
    </div>

    <script>
        /***********************************************
         * FULL working code for last 10 history & UI
         * - Auto-refresh every 5s
         * - Shows Period, Number, Big/Small, Color dots
         * - Tracks prediction history (WON/LOST)
         ***********************************************/

        // Configuration: display exactly last N results
        const HISTORY_DISPLAY_COUNT = 10;

        // API endpoints & request payloads (using the same ones you used)
        const API_CURRENT_ISSUE = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
        const API_PREV_RESULTS = 'https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList';

        // Make sure pageSize matches HISTORY_DISPLAY_COUNT
        function prevResultsRequestBody() {
            return {
                pageSize: HISTORY_DISPLAY_COUNT,
                pageNo: 1,
                typeId: 1,
                language: 0,
                random: "c2505d9138da4e3780b2c2b34f2fb789",
                signature: "7D637E060DA35C0C6E28DC6D23D71BED",
                timestamp: 1727792520,
            };
        }

        function currentIssueRequestBody() {
            return {
                typeId: 1,
                language: 0,
                random: "40079dcba93a48769c6ee9d4d4fae23f",
                signature: "D12108C4F57C549D82B23A91E0FA20AE",
                timestamp: 1727792520,
            };
        }

        // State
        let previousResults = []; // raw API results (most recent first expected)
        let latestPeriod = null;
        let latestPrediction = null;
        let history = []; // tracking predicted periods & results [{ period, prediction, status }]

        // Utility: safe parse number
        function toNumberSafe(v) {
            const n = parseInt(v);
            return Number.isFinite(n) ? n : null;
        }

        // Map number to Big/Small and color-dot html and color class
        function getNumberDetails(num) {
            const number = toNumberSafe(num);
            if (number === null) {
                return { bigSmall: '-', numberColorClass: '', colorDotsHtml: '' };
            }

            const bigSmall = number >= 5 ? 'Big' : 'Small';

            // color class for the large number display
            let numberColorClass = '';
            if ([1, 3, 7, 9].includes(number)) numberColorClass = 'text-green-500';
            else if ([2, 4, 6, 8].includes(number)) numberColorClass = 'text-red-500';
            else if (number === 5) numberColorClass = 'text-pink-500';
            else if (number === 0) numberColorClass = 'text-purple-500';

            // dots logic using image-like mapping:
            const isGreen = [1, 3, 5, 7, 9].includes(number); // odd -> green-ish
            const isRed = [0, 2, 4, 6, 8].includes(number);   // even -> red-ish
            const isPink = [0, 5].includes(number);           // special combos

            let finalDots = [];
            // 7, 3, 1 -> single green dot
            if (isGreen && !isPink) finalDots.push('<span class="inline-block w-3 h-3 rounded-full mr-1" style="background-color: #10B981;"></span>');
            // 8, 4, 2 -> single red dot
            if (isRed && !isPink) finalDots.push('<span class="inline-block w-3 h-3 rounded-full mr-1" style="background-color: #EF4444;"></span>');
            // 5 -> green + pink
            if (number === 5) finalDots.push('<span class="inline-block w-3 h-3 rounded-full mr-1" style="background-color: #10B981;"></span>', '<span class="inline-block w-3 h-3 rounded-full" style="background-color: #EC4899;"></span>');
            // 0 -> red + pink
            if (number === 0) finalDots.push('<span class="inline-block w-3 h-3 rounded-full mr-1" style="background-color: #EF4444;"></span>', '<span class="inline-block w-3 h-3 rounded-full" style="background-color: #EC4899;"></span>');

            return { bigSmall, numberColorClass, colorDotsHtml: finalDots.join('') };
        }

        // Fetch current issue (period)
        async function fetchCurrentGameIssue() {
            try {
                const resp = await fetch(API_CURRENT_ISSUE, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                    body: JSON.stringify(currentIssueRequestBody())
                });

                if (!resp.ok) {
                    console.warn('GetGameIssue returned not ok:', resp.status);
                    return;
                }

                const json = await resp.json();
                if (json && json.code === 0 && json.data && json.data.issueNumber) {
                    const issueNumber = json.data.issueNumber;
                    // if changed, update the displayed period and fetch previous results
                    if (issueNumber !== latestPeriod) {
                        latestPeriod = issueNumber;
                        document.getElementById('period-number').textContent = latestPeriod.toString().slice(-17);
                        await fetchPreviousResults();
                    }
                }
            } catch (err) {
                console.error('fetchCurrentGameIssue error:', err);
            }
        }

        // Fetch previous results (last N defined by HISTORY_DISPLAY_COUNT)
        async function fetchPreviousResults() {
            try {
                const resp = await fetch(API_PREV_RESULTS, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                    body: JSON.stringify(prevResultsRequestBody())
                });

                if (!resp.ok) {
                    console.warn('GetNoaverageEmerdList returned not ok:', resp.status);
                    return;
                }

                const json = await resp.json();
                if (json && json.code === 0 && json.data && Array.isArray(json.data.list)) {
                    // API likely returns newest first. We'll keep that order.
                    previousResults = json.data.list.slice(0, HISTORY_DISPLAY_COUNT);
                    runPredictionLogicAndRender();
                } else {
                    console.warn('Prev results missing or malformed', json);
                }
            } catch (err) {
                console.error('fetchPreviousResults error:', err);
            }
        }

        // Prediction logic (simple anti-streak / counts like you had)
        function runPredictionLogicAndRender() {
            // Build numbers array (most recent first)
            const entries = previousResults
                .map(e => {
                    return {
                        number: toNumberSafe(e.number),
                        issue: e.issue ?? e.issueNumber ?? e.issueNo ?? '' // support various names
                    };
                })
                .filter(e => e.number !== null);

            // Count big/small and green/red
            let bigCount = 0, smallCount = 0, greenCount = 0, redCount = 0;
            entries.forEach(en => {
                if (en.number >= 0 && en.number <= 4) smallCount++;
                else bigCount++;

                if ([1, 3, 5, 7, 9].includes(en.number)) greenCount++;
                else redCount++;
            });

            // Last up to 10 for streak detection
            const recent = entries.slice(0, HISTORY_DISPLAY_COUNT);
            const lastTenBigSmall = recent.map(entry => (entry.number >= 0 && entry.number <= 4) ? 'SMALL' : 'BIGGG');
            const lastTenColors = recent.map(entry => ([1, 3, 5, 7, 9].includes(entry.number)) ? 'GREEN' : 'REDDD');

            // streak calc helper
            const calcStreak = arr => {
                if (!arr.length) return 0;
                const first = arr[0];
                let i = 1;
                while (i < arr.length && arr[i] === first) i++;
                return i;
            };

            const bigStreak = calcStreak(lastTenBigSmall) && lastTenBigSmall[0] === 'BIGGG' ? calcStreak(lastTenBigSmall) : 0;
            const smallStreak = calcStreak(lastTenBigSmall) && lastTenBigSmall[0] === 'SMALL' ? calcStreak(lastTenBigSmall) : 0;
            const greenStreak = calcStreak(lastTenColors) && lastTenColors[0] === 'GREEN' ? calcStreak(lastTenColors) : 0;
            const redStreak = calcStreak(lastTenColors) && lastTenColors[0] === 'REDDD' ? calcStreak(lastTenColors) : 0;

            // Basic anti-streak predictions
            const bigSmallPrediction = (bigStreak >= 3) ? 'SMALL' : (smallStreak >= 3) ? 'BIGGG' :
                (bigCount > smallCount) ? 'SMALL' : 'BIGGG';

            const colorPrediction = (greenStreak >= 3) ? 'REDDD' : (redStreak >= 3) ? 'GREEN' :
                (greenCount > redCount) ? 'REDDD' : 'GREEN';

            latestPrediction = `${bigSmallPrediction} | ${colorPrediction}`;
            document.getElementById('predicted-result').textContent = latestPrediction;

            // Add/Update history tracking (prediction status PENDING)
            if (latestPeriod && latestPrediction) {
                const periodSlice = latestPeriod.toString().slice(-17);
                const existing = history.find(h => h.period === periodSlice);
                if (!existing) {
                    history.unshift({ period: periodSlice, prediction: latestPrediction, status: "PENDING" });
                    // keep only last 100 history entries
                    if (history.length > 100) history = history.slice(0, 100);
                } else {
                    // keep prediction fresh
                    existing.prediction = latestPrediction;
                }
            }

            // Now mark the most recent prediction (the last completed period)
            // We assume previousResults[0] is the most recent completed result
            if (previousResults.length > 0) {
                const actual = previousResults[0];
                const actualNum = toNumberSafe(actual.number);
                if (actualNum !== null) {
                    const actualBigSmall = (actualNum >= 5) ? 'BIGGG' : 'SMALL';
                    const actualColor = ([1, 3, 5, 7, 9].includes(actualNum)) ? 'GREEN' : 'REDDD';
                    const actualPeriod = (actual.issue ?? actual.issueNumber ?? actual.issueNo ?? '').toString().slice(-17);

                    const histIndex = history.findIndex(h => h.period === actualPeriod);
                    if (histIndex !== -1 && history[histIndex].status === "PENDING") {
                        const prevEntry = history[histIndex];
                        const bigWin = prevEntry.prediction.includes(actualBigSmall);
                        const colorWin = prevEntry.prediction.includes(actualColor);
                        prevEntry.status = (bigWin || colorWin) ? "WON" : "LOST";
                    }
                }
            }

            renderHistoryTable();
            updateAnalysisSection();
        }

        // Render the history table (last N actual results)
        function renderHistoryTable() {
            const tbody = document.getElementById('history-table-body');
            tbody.innerHTML = '';

            // previousResults expected most recent first
            previousResults.slice(0, HISTORY_DISPLAY_COUNT).forEach((entry) => {
                // Support different property names for period
                const periodRaw = entry.issue ?? entry.issueNumber ?? entry.issueNo ?? entry.period ?? '';
                const periodDisplay = periodRaw.toString();

                const num = toNumberSafe(entry.number);
                const details = getNumberDetails(num);

                const tr = document.createElement('tr');
                tr.className = "bg-transparent border-b border-gray-700 hover:bg-gray-800";

                tr.innerHTML = `
                    <td class="py-3 px-1 font-medium text-white whitespace-nowrap">${periodDisplay}</td>
                    <td class="py-3 px-1 text-center font-extrabold text-xl ${details.numberColorClass}">${num !== null ? num : '-'}</td>
                    <td class="py-3 px-1 text-center">${details.bigSmall}</td>
                    <td class="py-3 px-1 text-center flex justify-center items-center">${details.colorDotsHtml}</td>
                `;

                tbody.appendChild(tr);
            });
        }

        // Update analysis: won/lost counts and progress bar
        function updateAnalysisSection() {
            let wins = 0, losses = 0;
            history.forEach(h => {
                if (h.status === "WON") wins++;
                else if (h.status === "LOST") losses++;
            });

            document.getElementById('won-count').textContent = wins;
            document.getElementById('lost-count').textContent = losses;

            const total = wins + losses;
            const winPct = (total > 0) ? (wins / total * 100).toFixed(2) : 0;
            document.getElementById('progress-bar-fill').style.width = `${winPct}%`;
        }

        // Initial fetch and interval
        fetchCurrentGameIssue(); // initial call
        // Also make sure we fetch previous results right away in case API returns without current issue update
        fetchPreviousResults();

        // Polling every 5s
        setInterval(async () => {
            await fetchCurrentGameIssue();
            // fetchPreviousResults() is called by fetchCurrentGameIssue when period updates,
            // but we also call periodically to refresh previousResults in case API updates
            await fetchPreviousResults();
        }, 5000);
    </script>
</body>

</html>
